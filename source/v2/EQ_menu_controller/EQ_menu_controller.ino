/*
Ver 2.0
menu com oled display
*/

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <EEPROM.h>
//#include "steppers.h"

#define i2c_display_Address 0x3c
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET -1
#define WHITE SH110X_WHITE
#define BLACK SH110X_BLACK

#define NUM_MEASURES 100 //adc measures to be averaged
#define V_BAT_FULL 4.1
#define V_BAT_LOW_WARNING 3.3
#define V_BAT_EMPTY 3.1

#define SELECT D5
#define ROT_A D6
#define ROT_B D7

#define RATE_ROTATION_MICROS 1006500 //mudar

Adafruit_SH1106G display = Adafruit_SH1106G(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// 'eqmount_logo_clean', 128x64px
const uint8_t bitmap_eqmount_logo [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x01, 0xff, 0xc0, 0x00, 0x3c, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x3f, 0xf8, 0x1f, 0xf0, 0x00, 0x00, 0x0e, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x06, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0f, 0xff, 0x07, 0xfc, 0x00, 0x06, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x06, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x81, 0xff, 0x01, 0xf8, 0x07, 0x80, 0x0e, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xef, 0xce, 0x00, 0xe3, 0xc1, 0xc0, 0x0c, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x1c, 0x00, 0x7f, 0xf1, 0xc0, 0x18, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x38, 0x00, 0x3f, 0xf1, 0x80, 0x70, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xef, 0xf8, 0x00, 0x3f, 0xf3, 0x80, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x87, 0xf8, 0x00, 0x3f, 0xf7, 0x01, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x0f, 0xf8, 0x00, 0x3f, 0xfe, 0x07, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3e, 0x7f, 0x00, 0x3e, 0x7e, 0x1e, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x79, 0xff, 0xc0, 0x39, 0xff, 0x7c, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0xe7, 0xfd, 0xfc, 0x3f, 0xc3, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x01, 0xcf, 0xfc, 0x7f, 0xff, 0x07, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x03, 0x9f, 0xfe, 0x0f, 0xfc, 0x1f, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x03, 0x1f, 0xff, 0x03, 0xfe, 0x7c, 0x70, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x03, 0x0f, 0xf7, 0xff, 0xdf, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x03, 0x80, 0x07, 0xff, 0x1f, 0xff, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0xff, 0xff, 0xba, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0xff, 0xf0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0xfc, 0x3f, 0xf8, 0x00, 0xff, 0xf0, 0x7f, 0xfe, 0x3b, 0x80, 0x0c, 0xff, 0xfc, 0xff, 0xfc, 
	0xff, 0xfc, 0x7f, 0xfc, 0x00, 0xff, 0xf8, 0x7f, 0xff, 0x39, 0xc0, 0x1c, 0xff, 0xfd, 0xff, 0xfc, 
	0xe0, 0x00, 0xe0, 0x1e, 0x00, 0xc0, 0x3c, 0x70, 0x03, 0x39, 0xc0, 0x18, 0xc0, 0x01, 0xc0, 0x0e, 
	0xc0, 0x01, 0xc0, 0x06, 0x00, 0xc0, 0x0e, 0x70, 0x03, 0xb8, 0xe0, 0x38, 0xc0, 0x01, 0xc0, 0x0e, 
	0xc0, 0x01, 0xc0, 0x07, 0x00, 0xc0, 0x0e, 0x70, 0x03, 0xb8, 0xe0, 0x30, 0xc0, 0x01, 0xc0, 0x0e, 
	0xc0, 0x01, 0xc0, 0x07, 0x00, 0xc0, 0x0e, 0x70, 0x03, 0x38, 0x70, 0x70, 0xc0, 0x01, 0xc0, 0x0e, 
	0xcf, 0xf1, 0xc0, 0x07, 0x00, 0xc0, 0x06, 0x70, 0x07, 0x38, 0x70, 0x60, 0xcf, 0xf1, 0xc0, 0x0e, 
	0xcf, 0xf9, 0xc0, 0x07, 0x00, 0xc0, 0x06, 0x77, 0xff, 0x38, 0x38, 0xe0, 0xdf, 0xf1, 0xcf, 0xfc, 
	0xcf, 0xf1, 0xc0, 0x07, 0x00, 0xc0, 0x06, 0x77, 0xfe, 0x38, 0x38, 0xc0, 0xcf, 0xf1, 0xdf, 0xf8, 
	0xc0, 0x01, 0xc0, 0x07, 0x00, 0xc0, 0x0e, 0x77, 0xf8, 0x38, 0x1d, 0xc0, 0xc0, 0x01, 0xdf, 0xf0, 
	0xc0, 0x01, 0xc0, 0x07, 0x00, 0xc0, 0x0e, 0x70, 0xf0, 0x38, 0x1f, 0x80, 0xc0, 0x01, 0xc3, 0xc0, 
	0xc0, 0x00, 0xe0, 0x0e, 0x00, 0xc0, 0x1c, 0x70, 0x78, 0x38, 0x0f, 0x80, 0xc0, 0x01, 0xc1, 0xe0, 
	0xe0, 0x00, 0xf0, 0x1e, 0x00, 0xe0, 0x7c, 0x70, 0x3c, 0x38, 0x0f, 0x80, 0xe0, 0x01, 0xc0, 0xf0, 
	0x7f, 0xfc, 0x7f, 0xfc, 0x00, 0xff, 0xf8, 0x70, 0x1e, 0x38, 0x07, 0x00, 0xff, 0xfd, 0xc0, 0x3c, 
	0x3f, 0xfc, 0x3f, 0xf8, 0x00, 0xff, 0xe0, 0x70, 0x0f, 0x38, 0x07, 0x00, 0x7f, 0xfc, 0xc0, 0x1c, 
	0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// custom chars, 8x7px
const uint8_t saving[] PROGMEM = {0x00, 0x1e, 0x1f, 0x11, 0x11, 0x1f, 0x1f}; //card
const uint8_t lock[] PROGMEM   = {0x0e, 0x11, 0x11, 0x1f, 0x1b, 0x1b, 0x1f}; //cadeado
const uint8_t done[] PROGMEM   = {0x00, 0x00, 0x01, 0x03, 0x16, 0x1c, 0x08}; //ok
const uint8_t alert[] PROGMEM  = {0x0e, 0x1b, 0x1b, 0x1f, 0x1b, 0x0e}; //cuidado

//menu options (limited to given size)
enum menu_option{
    DEC_ = 0,
    RA,
    hemisphere,
    automatic_mode,
    manual_mode,
    brilho_tela,
    tempo_tela,
    save_configs,
    _menu_size //must be the last value
};
const uint8_t MENU_SIZE = _menu_size;
const char* menu_str[] = {
    "DEC",
    "R.A",
    "Hemisferio", 
    "Modo automatico",
    "Modo manual",
    "Contraste", 
    "Luz da tela",
    "Salvar configs"
};
uint16_t menu_op_value[MENU_SIZE] = {0};
const uint8_t OPTION_ROWS = 5;

volatile uint32_t value_preview = 0;
uint32_t lock_value;

uint32_t action_last_time = 0;
uint32_t ra_last_time = 0;
uint32_t time_now = 0;

volatile uint8_t actual_menu_top_row = 0;
uint8_t arrow_row = 0;
uint8_t current_selection;

volatile bool wake_flag     = false;
volatile bool select_pressed = 0;
bool sleeping = false;
bool on_menu = 1;
bool low_battery_flag = false;

void IRAM_ATTR rotary_spin_ISR();
void IRAM_ATTR rotary_press_ISR();
uint8_t analog_to_battery_percent(uint16_t analog_measure);

void setup()    {
    delay(250); //estabilizar a tens√£o
    Serial.begin(115200);

    //data recover
    EEPROM.begin(MENU_SIZE);
    uint8_t stored_brightness = EEPROM.read(brilho_tela);
    uint8_t stored_light_time = EEPROM.read(tempo_tela);
    uint8_t stored_hemisphere = EEPROM.read(hemisphere);
    EEPROM.end();
    menu_op_value[brilho_tela] = stored_brightness; 
    menu_op_value[hemisphere]  = stored_hemisphere;
    menu_op_value[tempo_tela]  = stored_light_time;


    display.begin(i2c_display_Address, true);
    display.clearDisplay();
    display.drawBitmap(0, 0, bitmap_eqmount_logo, 128, 64, WHITE); //logo show-off
    display.display();
    delay(2500);

    display.clearDisplay();
    display.setContrast(stored_brightness*127/100); // dim display
    display.setTextSize(1);
    display.setTextColor(WHITE);
    display.setCursor(19, 5);
    display.println("Carregando Menu");
    display.display();

    
    //rotary encoder
    pinMode(ROT_A, INPUT);
    pinMode(ROT_B, INPUT);
    pinMode(SELECT, INPUT);
    attachInterrupt(digitalPinToInterrupt(ROT_A), rotary_spin_ISR, RISING);
    attachInterrupt(digitalPinToInterrupt(SELECT), rotary_press_ISR, RISING);

    //fake load suave 
    display.drawRoundRect(7, 32, 110, 8, 3, 1);
    for (uint8_t p = 10; p < 110; p++)    {
        display.fillRoundRect(7, 32, p, 8, 3, 1);
        display.display(); 
        delay(1000/(110));    
    }
    display.setTextWrap(false);
    display.clearDisplay();

    ra_last_time = micros();
    action_last_time = micros();
}


void loop()     {
    
    time_now = micros(); //reference for time calcs

    //battery display
    uint16_t samples = 0;
    for(uint8_t measures = 0; measures < NUM_MEASURES; measures++)  { //average readings
        samples += analogRead(A0)/10; //erase the last digit
    }

    uint8_t battery_percent = analog_to_battery_percent(samples*10/NUM_MEASURES); //take the mean and return the percentage
    display.drawRoundRect(107, 1, 20, 4, 1, WHITE);
    display.fillRoundRect(107, 1, battery_percent/5, 4, 1, WHITE);
    if (low_battery_flag) display.drawBitmap(98, 0, alert, 8, 6, WHITE);

    //wait screen configs
    if (wake_flag)  { //exit wait screen

        for (uint8_t cont = 0; cont < (menu_op_value[brilho_tela]*127)/100; cont++) {
            display.setContrast(cont); //bright up
            delay(10);
        }
        action_last_time = time_now;
        wake_flag = false;
        sleeping  = false;
    }
    else if (!sleeping && ((uint32_t)(time_now - action_last_time) >= (menu_op_value[tempo_tela]*1000000)))  { //seconds to us
        for (uint8_t cont = menu_op_value[brilho_tela]; cont > 0; cont--) {
            display.setContrast(cont); //dim down
            delay(10);
        }
        sleeping = true;
    }

    //manual and automode settings
    if (menu_op_value[manual_mode])   {
        //setar aqui os comandos do motor de passo em modo manual
        menu_op_value[automatic_mode] = false;
    }
    else if (menu_op_value[automatic_mode]) {
        //setar aqui os comandos do motor de passo em modo automatico

        if ((uint32_t)(time_now - ra_last_time) >= RATE_ROTATION_MICROS)    {
            menu_op_value[RA] = (menu_op_value[RA] + (menu_op_value[hemisphere]? 1 : -1)) % 1439; //RA change circulated
            ra_last_time = time_now;
        }
    }

    //menu movement
    display.setTextSize(1);
    current_selection = actual_menu_top_row+arrow_row; //qual option ta selecionada agora

    if (on_menu)    {
        
        for (int i = 0; i < OPTION_ROWS; i++)   {
            display.drawChar(0, 2+i*(52/(OPTION_ROWS-1)), (i==arrow_row?0xAF:0x00), WHITE, BLACK, 1); //setinha (0xAF) ou nada (0x00), depende da sele√ß√£o atual
            display.setCursor(9, 2+i*(52/(OPTION_ROWS-1)));
            display.print(menu_str[actual_menu_top_row+i]);

            switch (actual_menu_top_row+i) {

                case DEC_:  {
                    display.print(": ");
                    display.print(menu_op_value[DEC_]/60); display.print((char)0xF7); display.print(menu_op_value[DEC_]%60); display.print("'");
                }   break;

                case RA:    {
                    display.print(": ");
                    display.print(menu_op_value[RA]/60); display.print("h"); display.print(menu_op_value[RA]%60); display.print("m");
                }   break;

                case hemisphere:    {
                    display.print(": ");
                    display.print(menu_op_value[hemisphere]?"Sul":"Norte");
                }   break;

                case automatic_mode:    {
                    display.print(":");
                    display.print(menu_op_value[automatic_mode]?"ON":"OFF");
                }   break;

                case manual_mode:    {
                    display.print(": ");
                    display.print(menu_op_value[manual_mode]?"ON":"OFF");
                }   break;

                case tempo_tela:    {
                    display.print(": ");
                    display.print(menu_op_value[tempo_tela]); display.print("s");
                }   break;

                case brilho_tela:    {
                    display.print(": ");
                    display.print(menu_op_value[brilho_tela]); display.print("%");
                }   break;

                case save_configs:    {
                }   break;

                default:
                    display.print(": ");
                    display.print(menu_op_value[actual_menu_top_row+i]);
            }
        }

        if (select_pressed)    { //action on menu
            display.drawChar(0, 2+arrow_row*(52/(OPTION_ROWS-1)), 0x00, WHITE, BLACK, 1); //apaga a setinha antiga
            display.drawChar(3, 2+arrow_row*(52/(OPTION_ROWS-1)), 0xAF, WHITE, BLACK, 1); //redesenha a setinha deslocada
            display.display();
            delay(200);
            
            select_pressed = false; 
            on_menu       = !on_menu;
            value_preview = menu_op_value[current_selection];
            lock_value    = value_preview;
        }
        display.display();
        display.clearDisplay();

    }

    //change values sub-menu
    else   {
        display.setTextSize(1);
        display.setCursor(0, 4);
        display.println("Ajustando: ");
        display.setCursor(0, 14);
        display.print(menu_str[current_selection]); 
        
        display.setCursor(10, 32);
        display.setTextSize(2);
        switch (current_selection) {

            case DEC_: {  
                display.print("  "); display.print(value_preview/60); display.print((char)0xf7); display.print(value_preview%60); display.print("'");
            }   break;

            case RA:    {
                if (menu_op_value[automatic_mode])  {
                    (value_preview==menu_op_value[RA])?:value_preview=menu_op_value[RA];  //auto-shifting lock
                    display.drawBitmap(60, 52, lock, 8, 7, WHITE);
                }
                display.print("  "); display.print(value_preview/60); display.print("h"); display.print(value_preview%60); display.print("m");
            }   break;

            case hemisphere:    {
                value_preview>=1?value_preview=1:value_preview=0; //boolify
                display.print(value_preview?"Sul":"Norte");
            }   break;

            case automatic_mode:    {
                value_preview>=1?value_preview=1:value_preview=0; //boolify
                display.print("   "); display.print(value_preview?"ON":"OFF");
            }   break;

            case manual_mode:    {
                value_preview>=1?value_preview=1:value_preview=0; //boolify
                display.print("   "); display.print(value_preview?"ON":"OFF");
            }   break;

            case brilho_tela:   {
                value_preview>100?value_preview=100:value_preview; //percent
                display.print("   "); display.print(value_preview); display.print("%");
            }   break;

            case tempo_tela:    {
                value_preview>255?value_preview=255:value_preview; //8bit
                display.print("   "); display.print(value_preview); display.print(" s");
            }   break;

            case save_configs:  {
                display.setCursor(0, 32);
                display.print("Salvando...");
                display.drawBitmap(60, 52, saving, 8, 7, WHITE);
                display.display();
                uint8_t eeprom_brightness, eeprom_light_time, eeprom_Hemisphere;
                EEPROM.begin(MENU_SIZE);
                eeprom_brightness = EEPROM.read(brilho_tela);
                eeprom_light_time = EEPROM.read(tempo_tela);
                eeprom_Hemisphere = EEPROM.read(hemisphere);

                uint8_t brightness = menu_op_value[brilho_tela];
                uint8_t light_time = menu_op_value[tempo_tela];
                uint8_t Hemisphere = menu_op_value[hemisphere];
                //selective save
                if (eeprom_brightness != brightness)   {
                    EEPROM.write(brilho_tela, brightness);
                    delay(800); //simular espera do save
                }
                if (eeprom_light_time != light_time) {
                    EEPROM.write(tempo_tela, light_time);
                    delay(800);
                }
                if (eeprom_Hemisphere != Hemisphere) {
                    EEPROM.write(hemisphere, Hemisphere);
                    delay(800);
                }

                EEPROM.end();
                display.drawChar(60, 52, 0xDA, BLACK, BLACK, 2); //apaga o bitmap anterior
                display.drawBitmap(60, 52, done, 8, 7, WHITE); //desenha por cima um ok
                display.display();
                delay(500);
                on_menu = !on_menu; //sai automaticamente da tela de salvamento
            }   break;

            default:
                display.print(value_preview);
            
        }

        if (select_pressed && (current_selection!=save_configs))    { //press sem ser no save
            menu_op_value[current_selection] = value_preview; //salva o setting
            display.drawBitmap(60, 4, done, 8, 7, WHITE); //da o simbolo de ok;
            display.display();
            while (digitalRead(SELECT)) delay(800);
            select_pressed = false;
            on_menu      = !on_menu; //sai do sub-menu
            if (menu_op_value[automatic_mode])   ra_last_time = micros(); //inicia o modo automatico
        }
        
        display.display();
        display.clearDisplay();
    }

};

void IRAM_ATTR rotary_spin_ISR()   {
    bool clockwise = digitalRead(ROT_B);
    uint32_t interrupt_now = micros();
    static uint32_t last_Interrupt = 0;

    if ((uint32_t) (interrupt_now - last_Interrupt) > 10000)  { //debounce sem delay()
        wake_flag = true;

        if (on_menu)    {
            if (!clockwise)    { //anti horario
                if (arrow_row) --arrow_row;
                else if (actual_menu_top_row) --actual_menu_top_row; //guard pra signed assignment e limite superior do menu
            }
            else    { //horario
                if (arrow_row < OPTION_ROWS-1) ++arrow_row;
                else if (actual_menu_top_row != (MENU_SIZE-OPTION_ROWS)) ++actual_menu_top_row; //limite inferior do menu
            }
        }

        else    {
            if (!clockwise && value_preview) --value_preview; //guard pra signed assignment no anti horario
            else value_preview+=5;
        }

        last_Interrupt = micros();
    }

    while (digitalRead(ROT_A)); //so funfa com isso n sei pq
}

void IRAM_ATTR rotary_press_ISR()   {
    select_pressed = true;
    wake_flag      = true;
}

uint8_t analog_to_battery_percent(uint16_t analog_measure)  {
    //change this function later

    //aprroximated function of correction
    float volts = ((map(analog_measure, 10, 1020, 0, 50)/10.0) - .2);
    uint8_t percent = map(volts*10, V_BAT_EMPTY*10, V_BAT_FULL*10, 0, 100);
    
    if (!low_battery_flag && (volts <= V_BAT_LOW_WARNING)) low_battery_flag = true;
    return percent;
}